// Generated by stratus_vlg 19.22-s100  (92619.020517)
// Sun Mar 28 16:19:22 2021
// from ../../../..//memlib/c_parts/mac_plm_block_out_dma32.cc

`timescale 1ps / 1ps

      
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2017 Cadence Design Systems, Inc. All rights reserved worldwide.
//
// The code contained herein is the proprietary and confidential information 
// of Cadence or its licensors, and is supplied subject to a previously 
// executed license and maintenance agreement between Cadence and customer. 
// This code is intended for use with Cadence high-level synthesis tools and 
// may not be used with other high-level synthesis tools. Permission is only 
// granted to distribute the code as indicated. Cadence grants permission for 
// customer to distribute a copy of this code to any partner to aid in designing 
// or verifying the customer's intellectual property, as long as such 
// distribution includes a restriction of no additional distributions from the 
// partner, unless the partner receives permission directly from Cadence.
//
// ALL CODE FURNISHED BY CADENCE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, AND CADENCE SPECIFICALLY DISCLAIMS ANY WARRANTY OF NONINFRINGEMENT, 
// FITNESS FOR A PARTICULAR PURPOSE OR MERCHANTABILITY. CADENCE SHALL NOT BE 
// LIABLE FOR ANY COSTS OF PROCUREMENT OF SUBSTITUTES, LOSS OF PROFITS, 
// INTERRUPTION OF BUSINESS, OR FOR ANY OTHER SPECIAL, CONSEQUENTIAL OR 
// INCIDENTAL DAMAGES, HOWEVER CAUSED, WHETHER FOR BREACH OF WARRANTY, 
// CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR OTHERWISE.
//
////////////////////////////////////////////////////////////////////////////////
// Generated by bdw_memgen 19.22-s100
// Sun Mar 28 16:19:17 CDT 2021
module mac_plm_block_out_dma32(CLK, WE0, CE0, D0, A0, WEM0, CE1, Q1, A1);

      input CLK;
      input WE0;
      input CE0;
      input [31:0] D0;
      input [6:0] A0;
      input [31:0] WEM0;
      input CE1;
      input [6:0] A1;
      output [31:0] Q1;
      reg [31:0] Q1;
      reg[31:0] t_31;
      reg[31:0] t_30;
      reg[31:0] t_29;
      reg[31:0] t_28;
      reg[31:0] t_27;
      reg[31:0] t_26;
      reg[31:0] t_25;
      reg[31:0] t_24;
      reg[31:0] t_23;
      reg[31:0] t_22;
      reg[31:0] t_21;
      reg[31:0] t_20;
      reg[31:0] t_19;
      reg[31:0] t_18;
      reg[31:0] t_17;
      reg[31:0] t_16;
      reg[31:0] t_15;
      reg[31:0] t_14;
      reg[31:0] t_13;
      reg[31:0] t_12;
      reg[31:0] t_11;
      reg[31:0] t_10;
      reg[31:0] t_9;
      reg[31:0] t_8;
      reg[31:0] t_7;
      reg[31:0] t_6;
      reg[31:0] t_5;
      reg[31:0] t_4;
      reg[31:0] t_3;
      reg[31:0] t_2;
      reg[31:0] t_1;
      reg[31:0] t_0;
      reg[31:0] mem[99:0];

         ///////////////////////////////////////////////////////////////////////////////
         //
         // Copyright (c) 2017 Cadence Design Systems, Inc. All rights reserved worldwide.
         //
         // The code contained herein is the proprietary and confidential information 
         // of Cadence or its licensors, and is supplied subject to a previously 
         // executed license and maintenance agreement between Cadence and customer. 
         // This code is intended for use with Cadence high-level synthesis tools and 
         // may not be used with other high-level synthesis tools. Permission is only 
         // granted to distribute the code as indicated. Cadence grants permission for 
         // customer to distribute a copy of this code to any partner to aid in designing 
         // or verifying the customer's intellectual property, as long as such 
         // distribution includes a restriction of no additional distributions from the 
         // partner, unless the partner receives permission directly from Cadence.
         //
         // ALL CODE FURNISHED BY CADENCE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
         // KIND, AND CADENCE SPECIFICALLY DISCLAIMS ANY WARRANTY OF NONINFRINGEMENT, 
         // FITNESS FOR A PARTICULAR PURPOSE OR MERCHANTABILITY. CADENCE SHALL NOT BE 
         // LIABLE FOR ANY COSTS OF PROCUREMENT OF SUBSTITUTES, LOSS OF PROFITS, 
         // INTERRUPTION OF BUSINESS, OR FOR ANY OTHER SPECIAL, CONSEQUENTIAL OR 
         // INCIDENTAL DAMAGES, HOWEVER CAUSED, WHETHER FOR BREACH OF WARRANTY, 
         // CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR OTHERWISE.
         //
         ////////////////////////////////////////////////////////////////////////////////
         // Generated by bdw_memgen 19.22-s100
         // Sun Mar 28 16:19:17 CDT 2021
         always @(posedge CLK)
          begin :thread0
            if ({1'b0, CE0} == 2'd1) begin
               // Perform an address range check to prevent crashes on out of bounds
               // accesses in SystemC behavioral simulations.
               if ({1'b0, WE0} == 2'd1) begin
                  if (WEM0[0] == 1'b1) begin
                     t_0 = mem[A0];
                     t_0[0] = D0[0];
                     mem[A0] = t_0;
                  end
                  if (WEM0[1] == 1'b1) begin
                     t_1 = mem[A0];
                     t_1[1] = D0[1];
                     mem[A0] = t_1;
                  end
                  if (WEM0[2] == 1'b1) begin
                     t_2 = mem[A0];
                     t_2[2] = D0[2];
                     mem[A0] = t_2;
                  end
                  if (WEM0[3] == 1'b1) begin
                     t_3 = mem[A0];
                     t_3[3] = D0[3];
                     mem[A0] = t_3;
                  end
                  if (WEM0[4] == 1'b1) begin
                     t_4 = mem[A0];
                     t_4[4] = D0[4];
                     mem[A0] = t_4;
                  end
                  if (WEM0[5] == 1'b1) begin
                     t_5 = mem[A0];
                     t_5[5] = D0[5];
                     mem[A0] = t_5;
                  end
                  if (WEM0[6] == 1'b1) begin
                     t_6 = mem[A0];
                     t_6[6] = D0[6];
                     mem[A0] = t_6;
                  end
                  if (WEM0[7] == 1'b1) begin
                     t_7 = mem[A0];
                     t_7[7] = D0[7];
                     mem[A0] = t_7;
                  end
                  if (WEM0[8] == 1'b1) begin
                     t_8 = mem[A0];
                     t_8[8] = D0[8];
                     mem[A0] = t_8;
                  end
                  if (WEM0[9] == 1'b1) begin
                     t_9 = mem[A0];
                     t_9[9] = D0[9];
                     mem[A0] = t_9;
                  end
                  if (WEM0[10] == 1'b1) begin
                     t_10 = mem[A0];
                     t_10[10] = D0[10];
                     mem[A0] = t_10;
                  end
                  if (WEM0[11] == 1'b1) begin
                     t_11 = mem[A0];
                     t_11[11] = D0[11];
                     mem[A0] = t_11;
                  end
                  if (WEM0[12] == 1'b1) begin
                     t_12 = mem[A0];
                     t_12[12] = D0[12];
                     mem[A0] = t_12;
                  end
                  if (WEM0[13] == 1'b1) begin
                     t_13 = mem[A0];
                     t_13[13] = D0[13];
                     mem[A0] = t_13;
                  end
                  if (WEM0[14] == 1'b1) begin
                     t_14 = mem[A0];
                     t_14[14] = D0[14];
                     mem[A0] = t_14;
                  end
                  if (WEM0[15] == 1'b1) begin
                     t_15 = mem[A0];
                     t_15[15] = D0[15];
                     mem[A0] = t_15;
                  end
                  if (WEM0[16] == 1'b1) begin
                     t_16 = mem[A0];
                     t_16[16] = D0[16];
                     mem[A0] = t_16;
                  end
                  if (WEM0[17] == 1'b1) begin
                     t_17 = mem[A0];
                     t_17[17] = D0[17];
                     mem[A0] = t_17;
                  end
                  if (WEM0[18] == 1'b1) begin
                     t_18 = mem[A0];
                     t_18[18] = D0[18];
                     mem[A0] = t_18;
                  end
                  if (WEM0[19] == 1'b1) begin
                     t_19 = mem[A0];
                     t_19[19] = D0[19];
                     mem[A0] = t_19;
                  end
                  if (WEM0[20] == 1'b1) begin
                     t_20 = mem[A0];
                     t_20[20] = D0[20];
                     mem[A0] = t_20;
                  end
                  if (WEM0[21] == 1'b1) begin
                     t_21 = mem[A0];
                     t_21[21] = D0[21];
                     mem[A0] = t_21;
                  end
                  if (WEM0[22] == 1'b1) begin
                     t_22 = mem[A0];
                     t_22[22] = D0[22];
                     mem[A0] = t_22;
                  end
                  if (WEM0[23] == 1'b1) begin
                     t_23 = mem[A0];
                     t_23[23] = D0[23];
                     mem[A0] = t_23;
                  end
                  if (WEM0[24] == 1'b1) begin
                     t_24 = mem[A0];
                     t_24[24] = D0[24];
                     mem[A0] = t_24;
                  end
                  if (WEM0[25] == 1'b1) begin
                     t_25 = mem[A0];
                     t_25[25] = D0[25];
                     mem[A0] = t_25;
                  end
                  if (WEM0[26] == 1'b1) begin
                     t_26 = mem[A0];
                     t_26[26] = D0[26];
                     mem[A0] = t_26;
                  end
                  if (WEM0[27] == 1'b1) begin
                     t_27 = mem[A0];
                     t_27[27] = D0[27];
                     mem[A0] = t_27;
                  end
                  if (WEM0[28] == 1'b1) begin
                     t_28 = mem[A0];
                     t_28[28] = D0[28];
                     mem[A0] = t_28;
                  end
                  if (WEM0[29] == 1'b1) begin
                     t_29 = mem[A0];
                     t_29[29] = D0[29];
                     mem[A0] = t_29;
                  end
                  if (WEM0[30] == 1'b1) begin
                     t_30 = mem[A0];
                     t_30[30] = D0[30];
                     mem[A0] = t_30;
                  end
                  if (WEM0[31] == 1'b1) begin
                     t_31 = mem[A0];
                     t_31[31] = D0[31];
                     mem[A0] = t_31;
                  end
               end
            end
         end

         always @(posedge CLK)
          begin :thread1
            if ({1'b0, CE1} == 2'd1) begin
               // Perform an address range check to prevent crashes on out of bounds
               // accesses in SystemC behavioral simulations.
               Q1 <= mem[A1];
            end
            else begin
               Q1 <= 32'd0000000000;
            end
         end


endmodule

